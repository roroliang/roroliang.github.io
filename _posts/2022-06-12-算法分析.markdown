---
layout:		post
title:		"算法笔记-蛮力法"
subtitle:	"\"算法，算法分析\""
date:		2022-06-09 12:00:00
author:		"roroliang"
header-img:	"img/suanfa.jpg"
catalog:	ture
tags:
    - 算法
    - 学习
    - 蛮力
---

> "第一篇"

趁着期末顺便整理一下算法笔记吧









# 算法

## 蛮力法

最简单直接的解决问题的方法，常常直接基于问题的描述和所涉及的的概念定义。

### 选择排序

选择排序：开始的时候，扫描整个列表，找到最小元素，然后和第一个元素交换，

然后从第二个元素开始扫描，找到最后n−1 个元素中的最小元素，再和第二个元素交换位置，

把第二小的元素放在它的位置上，依次类推，在对列表元素扫描i（i的取值为0~n-2）遍的时候，

在后n-i个元素中选出最小的元素与A[i]做交换。

n-1遍时，被排好序。

![屏幕截图 2022-06-12 004912](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 004912.png)



```
算法 SelectionSort(A[0..n-1])
	//该算法用选择排序对给定数组排序
	//输入：一个可排序数组A[0..n-1]
	//输出：升序排列的数组A[0..n-1]
	for i←0 to n-2 do  #下表从0开始最后一个元素为n-1不用排
		min←i
		for j=i+1 to n-1 do
		if A[j]<A[min] min←j
		swap A[i] and A[min]
```

![屏幕截图 2022-06-12 010427](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 010427.png)

![屏幕截图 2022-06-12 135046](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 135046.png)

基本操作是键值比较即：A[j]<A[min]，这个比较是依赖于输入数组的规模。

时间复杂度为 ：$\theta(n^2)$



键的比较次数为：$\theta(n^2)$



键的交换次数为：$\theta(n)$



更精确为n-1。

### 冒泡排序

比较表中相邻元素，如果是逆序就交换位置，重复多次后最大元素沉到列表中最后一个位置上，

n-1遍就排好了，第i遍（i∈[0,n-2])如下图

![屏幕截图 2022-06-12 135212](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 135212.png)

```
算法 BubbleSort(A[0..n-1])
	//该算法用冒泡排序对数组A[0..n-1]进行排序
	//输入：一个可排序数组A[0..n-1]
	//输出：非降序排列的数组A[0..n-1]
	for i←0 to n-2 do
		for j←0 to n-2-i do
			if A[j+1]<A[j] swap A[j] and A[j+1]
```

![屏幕截图 2022-06-12 140824](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 140824.png)

时间复杂度为 ：$\theta(n^2)$



键的交换次数最差为：$\theta(n^2)$

### 顺序查找

简单地将给定列表中的连续元素和给定的查找键进行比较，直到遇到一个匹配的元素。

```
算法	SequentialSearch2(A[0..n],K)
	//顺序查找的算法实现，它用了查找键做限位器
	//输入：一个n个元素的数组A和一个查找键k
	//输出：第一个值等于K的元素的位置，如果找不到，返回-1
	A[n]←K
	i←0
	while A[j]≠K do
		i←i+1
	if i<n return i
	if i>n return -1
		
```



### 蛮力字符串匹配

字符串匹配问题的蛮力算法是显而易见的： 将模式对准文本的前 m个字符， 然后从左 到右匹配每一对相应的字符， 直到m对字符全部匹配（算法就可以停止了）或者遇到一对不 匹配的字符。 

在后一种情况下， 模式向右移一位， 然后从模式的第一个字符开始， 继续把 模式和文本中的对应字符进行比较。

 请注意， 在文本中， 最后一轮子串匹配的起始位置是n-m（假设文本位置的下标是从0到n-1)。在这个位置以后， 再也没有足够的字符可以匹 配整个模式了， 因此， 该算法也就没有必要再做比较了。

```
算法	BruteForceStringMatch(T[0..n-1],P[0..m-1])
	//该算法实现了蛮力字符串匹配
	//输入：一个n个字符的数组T[0..n-1],代表一段文本
	//	   一个m个字符的数组P[0..m-1],代表一个模式
	//输出：如果查找成功，返回文本的第一个匹配子串中第一个字符的位置
		   否则返回1
	for i←0 to n-m do
		j←0
		while j<m and P[j]=T[i+j]do
			j←j+1
			if j=m return i
	ruturn -1
```

![屏幕截图 2022-06-12 151431](https://roroliang.github.io/img/ala/屏幕截图 2022-06-12 151431.png)

时间复杂度(最坏)：$\theta(nm)$

时间复杂度（平均）：$\theta(n)$
